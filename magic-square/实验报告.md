# 魔方问题实验报告

## 实现方法

使用 BFS、DFS、IDDFS 和 A* 四种方法实现魔方求解。

A*实现

使用 std::priority_queue ，优先扩展 f(n) 值最小的节点。使用 std::unordered_map<std::string, int> 记录到达各状态的最小 g(n) 值，用于更新路径。

分析 我们设计的启发式函数为： h(n) = (所有面中，颜色不纯粹的面的数量) / 4 合理性分析: 一次旋转最多能影响并可能“修复”4个侧面（不含旋转的面本身）。因此，用“坏面”的数量除以4，可以得到一个保守的、到达目标状态所需的最少步数估计，这保证了 h(n) 不会高估实际代价，从而确保 A* 算法找到的解是最优的。
## 测试情况

对于测试点 4

| 实现方法            | 测试点4测试情况 (ms) | 备注                   |
| ------------------- | -------------------- | ---------------------- |
| A-Star (`return 0`) | 25250               | 无优化、对照组         |
| BFS                 | 8987                 |                        |
| DFS                 |                      | 当深度限制为10耗时极长 |
| IDDFS               | 8908                 |  性能与BFS相当，但内存使用更优，是较好的盲目搜索策略。                      |
| A-Star              | 2801                   | 采用不匹配的面的数量作为启发函数，即使是很简单的启发函数也可以有较大的性能提升   |

A* 算法的性能展示了启发式搜索的巨大威力。与无启发函数的对照组相比，性能提升了近 9倍。与表现最好的IDDFS相比，性能也提升了约 3倍。这清晰地表明，一个设计良好的启发式函数可以极大地减少需要探索的节点数量，从而显著提高搜索效率。
## 大模型使用情况

claude sonnet 4 辅助检查了 A* 算法中优先队列、g-score更新等逻辑的正确性，并提出了一些代码风格和结构上的优化建议。