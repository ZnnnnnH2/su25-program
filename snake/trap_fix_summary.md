# 陷阱处理修复总结

## 修复内容

根据 `fix.md` 的建议，对 `my-snake.cpp` 进行了以下修复：

### 1. 修正陷阱分值 (规则合规性修复)
**位置**: `read_state()` 函数中的物品解析部分
**修改**: 
```cpp
case -2: // 陷阱 - 根据游戏规则扣除10分
    s.items[i].value = -10;  // 原来是 -20，现在修正为 -10
    break;
```
**说明**: 严格按照游戏规则，陷阱扣除10分而不是20分。

### 2. 添加陷阱路径代价常量
**位置**: 游戏常量定义部分
**添加**:
```cpp
static constexpr int TRAP_STEP_COST = 30; // 陷阱步骤惩罚代价，用于路径规划中软性避开陷阱
```
**说明**: 这个常量用于在BFS路径规划中对陷阱格子施加额外代价，使算法倾向于选择非陷阱路径。

### 3. BFS路径规划中的陷阱惩罚
**位置**: `bfs_grid()` 函数中的四方向扩展部分
**添加**:
```cpp
// 计算陷阱惩罚 - 软性避开陷阱但不完全禁止通过
int extra_cost = 0;
if (M.is_trap(ny, nx)) {
    extra_cost += TRAP_STEP_COST; // 对陷阱格子施加额外代价，使路径规划倾向于避开
}

int new_total_cost = new_dist + new_snake_cost * SNAKE_COST_WEIGHT + extra_cost;
```
**说明**: 
- 对陷阱格子增加30点额外代价
- 这是"软约束"，不完全禁止通过陷阱，但会优先选择非陷阱路径
- 当必须通过陷阱才能生存时，算法仍然可以选择踩陷阱

### 4. 安全移动分析中的陷阱避免
**位置**: `last_choice()` 函数中的安全移动分析部分
**添加**:
```cpp
// 在安全移动分析中避免陷阱 - 只有在所有其他选项都不安全时才会考虑陷阱
if (M.is_trap(ny, nx)) {
    log_ss << ":TRAP|";
    continue;
}
```
**说明**: 在寻找安全移动方向时，优先避开陷阱。只有当所有非陷阱方向都不安全时，后续的"绝望移动分析"才会考虑踩陷阱。

### 5. 移动前的陷阱检查
**位置**: `decide()` 函数的最终移动决策部分
**添加**:
```cpp
// 9.5) 陷阱检测：如果下一步是陷阱且有安全的替代方案，尝试避开
if (M.is_trap(cy, cx)) {
    log_ss << "TRAP_NEXT_STEP:|";
    // 尝试寻找更安全的替代路径
    int choice = last_choice();
    // 注意：last_choice 中的绝望移动分析(DESPERATE_MOVE_ANALYSIS)仍然允许踩陷阱，
    // 这样当所有其他选项都比死亡更糟糕时，蛇仍然可以选择踩陷阱求生
    return {choice};
}
```
**说明**: 在执行计划的移动前进行最后检查，如果下一步是陷阱，会尝试寻找替代方案。

## 修复策略原理

### 软约束设计
所有陷阱处理都采用"软约束"而非"硬禁止"：
- **路径规划**: 增加代价而不是完全阻断
- **安全移动**: 优先避免但在绝望时允许
- **最终检查**: 寻找替代但保留踩陷阱选项

### 生存优先原则
修复保持了"生存优先"的核心策略：
- 失去10分比死亡要好
- 当被困时，踩陷阱是可接受的求生手段
- 绝望移动分析仍然允许陷阱作为最后选择

### 性能影响
- 陷阱检查增加的计算开销极小
- BFS中只增加了一次 `is_trap()` 检查和简单算术运算
- 不会影响0.7秒的时间限制要求

## 测试建议

可以通过以下场景测试修复效果：

1. **邻近陷阱**: 在蛇头附近放置陷阱和食物，确认优先选择非陷阱路径
2. **被困场景**: 只有陷阱格子可以移动时，确认蛇会踩陷阱而不是死亡
3. **分值检查**: 确认踩到陷阱后确实扣除10分而不是20分

## 代码风格

所有添加的代码都遵循原有的代码风格：
- 详细的注释说明修改原因和逻辑
- 保持一致的缩进和命名规范
- 使用清晰的变量名和常量名
- 添加了日志输出用于调试分析
