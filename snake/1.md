Awesome—let’s go deep. I’ll explain the **three changes** in precise, engineer-friendly terms:

1. a **one-step “future safe-zone” check** before moving,
2. switching **point-to-point pathfinding to A\*** (while keeping your global Dijkstra), and
3. replacing a **hard TTL cutoff** with a **soft decay** for expiring items.

I’ll cover: _what problem it solves_, _the exact rule/algorithm_, _how it integrates with your code_, _corner cases_, _complexity/perf_, and _how to test it_.

---

# 1) One-step “future safe-zone” check

## What problem this solves

When the safe zone shrinks at `next_tick`, your current “legal move” check only validates the **current** safe zone. That allows a move that is legal _now_ but will place your head **outside** the zone _immediately after shrink_, i.e., you step into a square that becomes lethal next tick. This is a classic “edge-of-ring” death.

## Exact rule (simple and correct)

When selecting the action for _this_ tick:

- Compute the zone that will be in force **when your head lands** (i.e., after one step).

  - If no shrink happens at or before `current_ticks + 1`, the zone is `s.cur`.
  - If a shrink happens by then (`current_ticks + 1 >= s.next_tick`), use `s.next`.

- Validate the candidate next cell `(ny, nx)` against **that** zone, not only the current zone. If it would be outside, that move is **forbidden/penalized** and you must pick another move (or open shield, or go to survival fallback).

## How to implement in _your_ code

You already have:

- `s.current_ticks`, `s.next_tick`, `s.cur`, `s.next`, and `in_safe_zone(Safe, y, x)`.

Right before you finalize a move `dir`:

```cpp
Safe zone_after_step = (s.next_tick != -1 && s.current_ticks + 1 >= s.next_tick)
                       ? s.next
                       : s.cur;

int ny = sy + DY[dir], nx = sx + DX[dir];
if (!in_safe_zone(zone_after_step, ny, nx)) {
    // 1) Try another safe direction, or
    // 2) If available, open shield, or
    // 3) Fall back to survival_strategy
}
```

### Where this sits in the pipeline

- After you’ve chosen a target and reconstructed the **first step** (via your parent-chain), but **before** returning the action.
- Also apply the check inside any “simple fallback” that scores directions—score should be `-∞` (or very large penalty) if the next cell will be outside the post-shrink zone.

## Corner cases

- `s.next_tick == -1`: no planned shrink; always use `s.cur`.
- Shrink occurs exactly on the next tick (`current_ticks + 1 == s.next_tick`): **must** use `s.next`.
- If _every_ direction is outside after shrink and shield is available, prefer `shield` (`action=4`) over a suicidal step.

## Complexity / performance

Negligible. You’re just swapping which `Safe` object you pass to `in_safe_zone`.

## Testing checklist

- Put head at the very edge; set `next_tick = current_ticks + 1`; verify a step that remains inside **next** zone is chosen, others are rejected.
- If no safe moves into `s.next`, verify shield opens (if allowed), then fallback.

---

# 2) Use **A\*** for single-goal pathfinding (keep Dijkstra for global maps)

## What problem this solves

You use a weighted Dijkstra (`bfs_grid` with a priority queue) to build global cost maps. That’s perfect when you need “distance to **all** cells”. But when you already know **one specific goal** (e.g., the next waypoint or a single food), Dijkstra explores many irrelevant cells. A\* uses a heuristic to **focus** the search, cutting expansions by 30–70% (typical on 4-neighbors grids with Manhattan).

## Exact algorithm (A\* on your grid)

- **State**: cell `(y, x)`.
- **g**: accumulated move cost (your step cost: 1 + optional penalties).
- **h**: heuristic = **Manhattan distance** to the goal (admissible because penalties are non-negative and Manhattan underestimates true cost).
- **f = g + h**: priority in the min-heap.
- Parent pointer: store `parent_dir` (or parent cell) exactly like your Dijkstra, so your existing `reconstruct_first_step` works the same.

### Heuristic choice

- Use `h = |y - gy| + |x - gx|`.
- Do **not** include penalties in `h`; keep it admissible (never overestimates).

## How it integrates with your code

- **Keep your Dijkstra** (`bfs_grid`) for:

  - building a global distance/cost map from your head,
  - global scoring of candidates, openness, flood-fill, etc.

- **Introduce a new helper** (e.g., `astar_first_step(M, s, start, goal) -> dir or -1`) and call it **only** when you have a **single goal** to move toward _this tick_. For example:

  - After you pick `goal = R.seq.front()` (or the second waypoint via your value-density tie-breaker),
  - Use `A*` to get the first step to that exact goal (more focused than re-running the global Dijkstra).

### Skeleton (conceptual)

```cpp
int astar_first_step(const GridMask& M, const State& s, Point start, Point goal) {
    // priority_queue on (f, y, x), store g[y][x], parent_dir[y][x]
    // g start = 0; f start = h(start)
    // pop node -> if (y,x)==goal stop; relax 4 neighbors:
    //   cost = g + stepCost(ny,nx)  (same penalties you already use)
    //   if cost improves: update g, parent_dir, push with f = cost + h(ny,nx)
    // after goal reached: parent-chain back to the first step; return dir or -1
}
```

> Step cost must match your Dijkstra’s step model (1 + trap penalty + near-enemy penalty, etc.) to keep behavior consistent.

## Corner cases

- If penalties can be huge and create non-Euclidean detours, A\* still works (h is still a lower bound).
- If the goal becomes unreachable (blocked), return `-1` so your code can replan or go survival.

## Complexity / performance

On a 40×30 grid (1200 cells), A\* often expands **far fewer** nodes than Dijkstra for a single target. This keeps you well within the **0.7 s** time budget even under multiple targets per turn.

## Testing checklist

- Compare node expansion counts / run time between Dijkstra and A\* for a single far target.
- Verify first-step direction equality with Dijkstra in obstacle setups (should match).

---

# 3) TTL: replace **hard cutoff** with **soft decay**

## What problem this solves

Your current candidate builder often **drops** items whose ETA (distance) is just greater than `lifetime`. In sparse boards this can zero out `CANDIDATES_COUNT` → you fall back to a “safe move” that may drift aimlessly.

## Exact scoring rule (soft decay)

Keep the candidate, but **decay** its score if you’re late. Let:

- `dist` = ETA to reach the item (using your cost model),
- `lt` = item’s remaining lifetime,
- `slack = dist - lt`.

Then:

- If `slack <= 0` (you arrive in time), score unchanged.
- If `slack > 0` (you arrive late), multiply score by an exponential decay:

  $$
  \text{score} \gets \text{score} \times \exp\!\left(-\frac{\text{slack}}{\tau}\right)
  $$

  where `τ` (tau) is a small constant, e.g., **3–5**.

Optionally add a **buffer** of 1–2 ticks before considering it “late”:

```cpp
int late = max(0, dist - (lt + grace));   // grace = 1 or 2
cand.score *= std::exp(- late / tau);     // tau ~ 4
```

## Why this works

- You keep _some_ candidates even if arrival is barely late; the planner can still choose them if all else is worse.
- As lateness grows, score shrinks fast → the plan naturally avoids hopeless items.

## How it integrates with your code

In the same place you currently do:

```cpp
if (dist > lifetime) continue; // hard drop
```

replace with:

```cpp
int late = dist - (lifetime + grace_ticks);  // grace ~ 1..2
if (late > 0) cand.score *= std::exp(- double(late) / tau);  // tau ~ 4
```

Keep a **cap** to prevent NaNs or extreme values:

- Clamp `cand.score` to `[0, MAX_SCORE]` after decay.
- If after decay it’s still tiny (`< eps`), you _may_ drop it to reduce noise.

## Corner cases

- Items with `lifetime == -1` (permanent): skip decay.
- Chest/Key chains: combine decay with feasibility check (e.g., key-to-chest ETA vs key’s drop timer).

## Complexity / performance

Trivial; a couple of arithmetic ops per candidate. No graph work added.

## Testing checklist

- Set a food with `lt=5`, distance `dist ∈ {4, 5, 6, 8}` and verify scores change smoothly rather than drop to zero.
- Compare `CANDIDATES_COUNT` before/after; you should see fewer “0 candidates” turns.

---

# Interactions and ordering (how they play together)

1. **Candidate building**: compute `dist` using your cost model (Dijkstra or A\*), apply **TTL soft decay** to the score rather than hard dropping.
2. **Plan selection**: pick best target(s) → build route (your greedy + local search).
3. **Action extraction**: for the chosen first waypoint, run **A\*** to get **the first step** efficiently (or reuse the parent map if you already have it).
4. **Safety gate**: right before returning the action, do the **one-step future safe-zone check**. If illegal post-shrink, pick a different move / open shield / survival fallback.
5. **Persist plan**: store waypoints in your memory string as you already do.

---

# Pitfalls to avoid

- **Heuristic must be admissible**: keep A\*’s `h` as Manhattan only; don’t add penalties to `h`.
- **Cost model consistency**: the step cost used by A\* and Dijkstra must match (1 + trap penalty + near-snake penalty, etc.), or you’ll see “A\* says reachable, Dijkstra says not” weirdness.
- **Boundary equality**: don’t forget the `==` in `current_ticks + 1 >= next_tick`. Shrink _on the next tick_ must use `s.next`.
- **Decay parameters**: start with `grace=1` and `tau=4`. If you still see too many late chases, reduce `grace` or lower `tau`; if you’re too timid, increase `tau`.

---

# How to validate quickly

- **Unit-style micro tests**:

  - Safe-zone edge: craft a 5×5 board, shrink at `t+1`, verify the selected move remains inside `s.next`.
  - TTL: item at distance 6 with `lt=5`; confirm it remains a candidate but with reduced score.
  - A\*: single far goal with scattered traps; log expanded nodes and compare to Dijkstra (should be fewer).

- **Integration logs** (you already log well): add fields like

  - `FUTURE_SAFE=<0/1>` per candidate direction,
  - `TTL_DECAY:late=...,tau=...,newScore=...`,
  - `ASTAR_EXPANDED=.../DIJKSTRA_EXPANDED=...`.

---

If you want, I can drop in a minimal `astar_first_step(...)` that matches your existing types (same `GridMask`, `State`, `DY/DX`, and returns a direction `0..3`), and a tiny patch for the TTL decay line.
