1. Communication protocol
The algorithmic program runs once per tick tick, reads the game state for each tick via standard input (stdin), and submits decisions through standard output (stdout).

2. Input format
At the beginning of each game tick, game state information is sent in plain text to the algorithm's standard input. All coordinate information follows the order of y x.

There are still game moments left
Total number of items
y1 x1 v1 t1
...
Total number of snakes
id1 len1 score1 dir1 shield_cd1 shield_time1
y1_1 x1_1
...
id2 len2 score2 dir2 shield_cd2 shield_time2
...
Total number of chests
y_chest1 x_chest1 score1
...
Total number of keys
y_key1 x_key1 holder_id1 remaining_time1
...
Current Security Zone _xmin Current Security Zone _ymin Current Security Zone _xmax Current Security Zone _ymax
next contraction moment next safe zone _xmin next safe zone _ymin next safe zone _xmax next safe zone _ymax
final contraction moment final safe zone _xmin final safe zone _ymin final safe zone _xmax final safe zone _ymax

[Optional] Data stored in the Memory system in the previous round
1. Item information
It starts with the total number of items on the field, followed by each row representing an item in the format y x v t.

Meaning of item value v:
1 to 5: Normal food, with corresponding scores.
-1: Grow beans.
-2: Trap.
- 3: Key (on the ground, pickable).
-5: Treasure chest (considered an obstacle if you do not hold the key).
The last number, t, indicates the remaining survival time (tick) of the item. If the item never disappears, t is -1.

2. Player Information
After the item information, there is the total number of snakes alive, followed by specific information about each snake.

The first line is the comprehensive attributes of snakes:
id: Player ID (i.e. student number).
len: The current length of the snake.
score: The current score.
dir: The current direction of movement (0-left, 1-up, 2-right, 3-down).
shield_cd: Shield cooldown (0 is available).
shield_time: Shield remaining validity time.
The subsequent len line is the coordinates of each section of the snake's body, from the snake's head to the snake's tail.
3. Chests and keys Additional information
The first is a number representing the number of unopened chests (currently it can only be 0 or 1)
Then there's the chest information: in the format y x score, it indicates the chest's coordinates and the score you can get when you open it.
Then there is a number that represents the total number of all keys on the field (both on the ground and held by the snake)
Finally, the information for each key: in the format y x holder_id remaining_time.
holder_id: If -1, it means the key is on the ground; Otherwise, it is the player ID that holds the key.
remaining_time: If the key is held, this is the remaining time for the automatic drop; If on the ground, this value is 0.
4. Safe Zone Information
The input information ends with three lines of data about the safe zone

First line: xmin ymin xmax ymax, describing the boundaries of the current safe zone.
Second row: next_tick next_xmin next_ymin next_xmax next_ymax. The next_tick here represents the moment when the next boundary actually changes (i.e., the first moment when the next boundary contracts inward from the current boundary), and gives the target boundary corresponding to that moment. If there is no change in the future, the next_tick is -1, and the boundary repeats the current value.
Third row: final_tick final_xmin final_ymin final_xmax final_ymax. Indicates the "moment of completion of the current/next contraction phase" and the final boundary when reached; If the safe zone no longer shrinks, the final_tick is -1.
5. Enter an example
Here is an example of the full input data at a certain point in the late game (tick 217):

39
17
19 16 1 4
12 31 -1 25
14 19 3 11
14 17 1 11
5 16 5 20
16 14 -1 40
13 30 3 26
9 32 -2 46
17 14 1 35
14 14 1 38
23 21 3 38
22 32 2 44
11 18 3 50
19 30 1 53
10 21 -5 -1
5 13 -3 -1
19 11 -3 -1
1
2000000000 9 82 0 0 0
17 17
17 18
17 19
17 20
17 21
17 22
17 23
17 24
17 25
1
10 21 30
2
5 13 -1 0
19 11 -1 0
7 5 32 24
228 8 5 31 24
241 10 7 29 22
1 5 13
Data interpretation:

Game progression: 39 ticks remaining (currently 256-39=217 ticks).
Items: There are a total of 17 items on the field, including high-scoring food, growth beans, traps (-2), a chest (-5), and two keys on the ground (-3).
Snake: There is 1 snake on the field.
ID 2000000000: Length is 9 with a score of 82. The shield is currently facing left (0), and the shield is available.
Chests and Keys: There is 1 chest worth 30 points and 2 keys on the ground (holder_id = -1).
Safe Zone:
The current safe zone is 7 5 32 24.
The final contraction will begin on tick 228 (when the boundary becomes 8 5 31 24) and will finish on tick 241 with a final boundary of 10 7 29 22.
MemoryData: 1 5 13 was stored in the last turn.
3. Output format
Your algorithm needs to print an integer to the standard output (stdout) as the decision for this round.

0: Move to the left
1: Move up
2: Move to the right
3: Move down
4: Activate the shield (stay in place for one turn)
4. Persistent storage (Memory system)
To support complex algorithms that require cross-turn memory of states, the platform provides a persistent storage (Memory) system. Each algorithm instance has a separate, read/write data space in a single game.

1. Data writes
After your program outputs the decision (integer of 0-4) and wraps the line, you can proceed to output the string in any format. This part of the string will be captured by the system and stored in your dedicated Memory space. Please note: each write completely overwrites the last stored content.

For example, output the following:

2
TARGET:10,20; STATE:ATTACK; PREV_SCORE:150
The system will submit decision 2 (to the right) to the game engine and put the string TARGET:10,20 in the second line; STATE:ATTACK; PREV_SCORE:150 is deposited in your Memory.

Note that this is just an example, and it is actually possible to store content in any text format. The maximum limit is 4KB.

2. Data reading
At the next game moment, your previous round saved content will be appended to the end of the standard input as is, after all regular game state information (safe zone information, etc.).

At the first tick of the game, the Memory section will be empty (i.e., the input ends directly after the safe zone information) as there is no storage for the previous round.

5. Restrictions and error handling
1. Resource constraints
CPU time limit: 1 second
Memory limit: 1GB
Wall clock limit: 5 seconds
2. Decision failure
Your snake will be judged to have failed to make a decision and die immediately if the algorithmic program has the following:

Program crashes or abnormal exits.
Exceeding the time or memory limit.
Invalid decision values are output.
Decisions lead directly to crashing into map boundaries or other deadly obstacles.
6. Running environment and compilation
1. Operating environment
Your code will compile and run on an x86-64 architecture Linux server. The compiler version we are using is g++ 14.2.0.

2. Compile commands
The platform will use the following command to compile your .cpp file. Make sure your code works properly in this environment with the compilation options.

g++ -std=c++23 -O2 -Wall your_file.cpp -o program